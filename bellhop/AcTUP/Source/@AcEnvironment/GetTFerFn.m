function [TFerFnMatrix, FVec, HRange, ZRx] = GetTFerFn(Environment, Source, HRange, ZRx)
%TFerFnMatrix = GetTFerFn(Environment, Source, HRange, ZRx)
%
%Returns a transfer function matrix for a set of receiver (horizontal range, depth) pairs
%Each row has data for a given receiver position
%
%Environment - AcEnvironment object
%Source - Source object
%HRange - vector of horizontal ranges from the source to the receiver.  If empty the transfer function
%         is output at the ranges at which it was calculated by Scooter.
%ZRx - vector of receiver depths (below the water surface).  If empty the the transfer function is output at the
%      first depth at which it was calculated by Scooter.



DirInfo = GlblGetDirectoryInfo;


if ~isempty(ZRx)   
   ZRx = reshape(ZRx, length(ZRx), 1);
end


SourceName = GetLabel(Source);

[FName, dF, FMin, FMax] = lGetTFFnFileInfo(Environment, SourceName);
FVec = FMin:dF:FMax;

if ~isempty(HRange)
    HRange = reshape(HRange, length(HRange), 1);
    TFerFnMatrix = zeros(length(HRange), length(FVec));
end

%keyboard
if isempty(FName)
   error(['Couldn''t find transfer function files for source: ' SourceName]);
end

FileID = fopen( [FName '.shd'], 'r' );
if FileID < 0
   error(['Couldn''t open Scooter output file: ' FName '.shd']);
end

ThisF = FMin;
IFreq = 1;
Done = 0;
while ~Done  %Process one frequency at a time
   Shd = lReadShadeFile(FileID);
   if isempty(Shd)
      Done = 1;
   else
      if (IFreq == 1)
         if isempty(HRange)
            HRange = Shd.RxRanges;
            TFerFnMatrix = zeros(length(HRange), length(FVec));
         end
         
         if isempty(ZRx)
            ZRx = Shd.RxDepths(1);
         end
      end
        
  	  TFerFn = Shd.Pressure;
      RVec = Shd.RxRanges;

   	  %Interpolate magnitude and phase
   	  %This requires that Scooter has been run with sufficiently small range and depth steps that the
   	  %phase change between adjacent points  is < pi radians.
   	  Phase = unwrap(angle(TFerFn));
      AbsMag = abs(TFerFn);
      
   	  if length(Shd.RxDepths) == 1
      	%1D interpolation
        if IFreq == 1
            [IndAlpha, IndBeta, Alpha, Beta] = lGetInterpIndex(RVec, HRange);
        end
      	if max(abs(Shd.RxDepths - ZRx)) > 0.1
         	error(['Shade file depth does not match receiver depth in file ' FName]);
      	end
      	%IntMag = interp1(RVec, abs(TFerFn), HRange, '*linear');
        IntMag = Alpha .* AbsMag(IndAlpha) + Beta .* AbsMag(IndBeta);
        
      	%IntPhase = interp1(RVec, Phase, HRange, '*linear');
        IntPhase = Alpha .* Phase(IndAlpha) + Beta .* Phase(IndBeta);

   	  else
      	%2D interpolation
      	[ZMat, RMat] = meshgrid(Shd.RxDepths, RVec);
      	IntMag = interp2(ZMat, RMat, abs(TFerFn), ZRx, HRange, '*linear');
      	IntPhase = interp2(ZMat, RMat, Phase, ZRx, HRange, '*linear');
      end
      
      %Put data for this frequency into the appropriate column of the transfer function matrix
      [Dum, TFIndex] = min(abs(FVec - Shd.Freq));
      
      %Minus sign added 16/2/01 so that time domain waveform generated by this method had same sign as waveform 
      %generated by image method(s), which are consistent with transmit signal.
   	  TFerFnMatrix(:, TFIndex) = -IntMag .* exp(i*IntPhase); 
      IFreq = IFreq+1;
   end
   if LibCheckAbort
       Done = 1;
   end
end
fclose(FileID);   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function ShadeStruct = lReadShadeFile(FileID)
[ Title, Freq, Nsd, Nrd, Nrr, Sd, Rd, Rr, Tlt, FileStatus ] = ReadShadeBin( FileID );
if FileStatus
    ShadeStruct.Title = Title; 
    ShadeStruct.Freq = Freq;
    ShadeStruct.SourceDepth = Sd;
    ShadeStruct.RxDepths = Rd;
    ShadeStruct.RxRanges = Rr;
    ShadeStruct.Pressure = Tlt(:, :, 1).';
else
    ShadeStruct = [];
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [FName, dF, FMin, FMax] = lGetTFFnFileInfo(Environment, SourceName)
%Look through the data base of runs to find the required filename
Done = 0;
IArr = 1;
FName = [];

while ~Done
   if IArr > length(Environment.TFFnData)
      Done = 1;
   else
   	Data = Environment.TFFnData{IArr};
      Match = strcmp(Data.SourceName, SourceName);
      if ~isempty(Match)
         Done = 1;
         FName = Data.FileName;
         dF = Data.dF;
         FMin = Data.FMin;
         FMax = Data.FMax;
      else
         IArr = IArr+1;
      end
   end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [IndAlpha, IndBeta, Alpha, Beta] = lGetInterpIndex(X, XI);
%Computes interpolation parameters
%so that interpolated Y values can be calculated from:
%YI = AlphA .* Y(IndAlpha) + Beta .* Y(IndBeta)

[Dum, IndAlpha] = histc(XI, X);
IndAlpha(XI < X(1)) = 1;
IndAlpha(XI >= X(end)) = length(X)-1;
IndBeta = IndAlpha + 1;
X1 = X(IndAlpha);
X2 = X(IndBeta);

Alpha = (X2 - XI) ./ (X2 - X1);
Beta = 1 - Alpha;

   
